
  1. Represent Hand Ranks

  It would be helpful to represent the Teen Patti hand hierarchy in a structured way. An Enum is perfect for this. You could add
  a HandRank enum at the top of your teen_patti.py file. The order is important, from highest to lowest.

    1 # In teen_patti.py
    2 from enum import Enum
    3
    4 class HandRank(Enum):
    5     TRIO = 6
    6     STRAIGHT_FLUSH = 5
    7     STRAIGHT = 4
    8     FLUSH = 3
    9     PAIR = 2
   10     HIGH_CARD = 1

  2. Create a Hand Evaluator

  You can create a new method in your TeenPatti class, let's call it _evaluate_hand, that takes a player's three cards and
  determines its rank.

  This method would perform the following steps:

   * Convert Ranks to Numbers: Your card ranks are strings ('J', 'Q', etc.). For easier comparison, map them to numerical values.
     You can use the index from your CardDeck.ranks list for this, where 'Ace' would have the highest value.
   * Sort the Cards: Sort the three cards based on their numerical rank. This makes checking for sequences and pairs much easier.
   * Check for Hands (Highest to Lowest): Check for each hand type in order of precedence.
       * Is it a Trio? Are all three card ranks the same?
       * Is it a Straight Flush (Pure Sequence)? Are the cards in sequence AND do they all have the same suit?
       * Is it a Straight (Sequence)? Are the cards in sequence? (Handle the special case of A-2-3).
       * Is it a Flush (Color)? Do all three cards have the same suit?
       * Is it a Pair? Do two of the three cards have the same rank?
       * If none of the above, it's a High Card.

  The _evaluate_hand method should return the HandRank enum and the sorted numerical values of the cards for tie-breaking. For
  example: (HandRank.PAIR, [12, 12, 5]) for a pair of Queens and a 5.

  3. Implement the Winning Logic in rules()

  Your rules(self, players) method in teen_patti.py is the perfect place to determine the winner.

   * Loop Through Players: Iterate through the players dictionary.
   * Evaluate and Store: For each player, call your new _evaluate_hand method to get their hand rank and card values. You could
     store this information in a new dictionary or directly on the player's data.
   * Find the Winner: Keep track of the player with the best hand found so far.
       * Start by assuming the first player is the winner.
       * For each subsequent player, compare their hand to the current winner's hand.
       * Comparison:
           1. First, compare their HandRank (e.g., TRIO > PAIR).
           2. If the ranks are the same (e.g., both have a PAIR), use the sorted card values for tie-breaking. For a pair, you'd
              compare the value of the paired cards first. If those are also the same, you'd compare the third card (the "kicker").

  By the end of the loop, you will have identified the winning player.
  This approach keeps the hand evaluation logic separate and clean, and uses the rules method to orchestrate the process of
  finding a winner for each round, fitting nicely into your existing structure.
  def play_game_loop(self):
    4         """Runs the game from start to finish using a console-based while loop."""
    5 
    6         print("\n--- Starting New Game Loop ---")
    7         # You could add logic for an initial blind bet here
    8 
    9         while True:
   10             # --- 1. Check for a winner ---
   11             # An active player is one who has not folded
   12             active_player_ids = [pid for pid, data in self.players.items() if not data['has_folded']]
   13
   14             if len(active_player_ids) <= 1:
   15                 winner_id = active_player_ids[0] if active_player_ids else None
   16                 if winner_id:
   17                     print(f"\n--- GAME OVER ---")
   18                     print(f"Player {winner_id} is the last one remaining!")
   19                     print(f"Player {winner_id} wins the pot of {self.game_pot}")
   20                     # Award the winnings
   21                     self.players[winner_id]['money'] += self.game_pot
   22                     self.game_pot = 0
   23                 else:
   24                     print("--- GAME OVER --- \nNo players left.")
   25                 break  # Exit the while loop
   26
   27             # --- 2. Get the current player ---
   28             current_player_id = self.get_current_player_id()
   29             player_data = self.players[current_player_id]
   30
   31             # This player has already folded, so we skip their turn
   32             if player_data['has_folded']:
   33                 self._advance_turn()
   34                 continue
   35
   36             # --- 3. Display info and get player input ---
   37             print("\n" + "="*30)
   38             print(f"Total Pot: {self.game_pot}")
   39             print(f"Current Turn: Player {current_player_id} (Money: {player_data['money']})")
   40
   41             # This is how you show cards only to the current player in a console game
   42             print(f"Player {current_player_id}, your cards are: {player_data['cards']}")
   43
   44             action = input("Choose your action ('bet' or 'fold'): ").lower().strip()
   45
   46             # --- 4. Process the chosen action ---
   47             if action == 'fold':
   48                 print(f"Player {current_player_id} has folded.")
   49                 player_data['has_folded'] = True
   50
   51             elif action == 'bet':
   52                 try:
   53                     # For simplicity, we'll use a fixed bet amount for now
   54                     bet_amount = 10.0
   55                     if bet_amount > player_data['money']:
   56                         print("Not enough money to bet. You automatically fold.")
   57                         player_data['has_folded'] = True
   58                     else:
   59                         player_data['money'] -= bet_amount
   60                         self.game_pot += bet_amount
   61                         print(f"Player {current_player_id} bets {bet_amount}.")
   62                 except ValueError:
   63                     print("Invalid input. Please try again.")
   64                     continue # Let the player repeat their turn
   65
   66             else:
   67                 print("Invalid action. Please choose 'bet' or 'fold'.")
   68                 continue # Let the player repeat their turn
   69
   70             # --- 5. Advance to the next player ---
   71             self._advance_turn()



   
 class Room:
   10     def __init__(self, room_id: str, max_players: int = 6):
   11         self.room_id = room_id
   12         self.max_players = max_players
   13         self.players: dict[int, Player] = {}  # Stores the actual Player objects
   14
   15         # This is the key attribute. It will hold the active game instance.
   16         self.current_game = None
   17
   18     def add_player(self, player: Player):
   19         """Adds a player to the room before a game starts."""
   20         if len(self.players) < self.max_players:
   21             self.players[player.player_id] = player
   22             print(f"Player {player.player_name} has joined room {self.room_id}.")
   23         else:
   24             print("Cannot add player, room is full.")
   25
   26     def start_game(self, game_type: str):
   27         """
   28         Starts a new game in the room with the current players.
   29         This method acts like a "factory" for games.
   30         """
   31         if self.current_game is not None:
   32             print("A game is already in progress in this room.")
   33             return
   34
   35         print(f"\nStarting a new game of '{game_type}' for {len(self.players)} players.")
   36
   37         # We still use the asdict approach to pass data to the game engine
   38         players_data = {pid: asdict(p) for pid, p in self.players.items()}
   39
   40         game_instance = Game(
   41             game_id=f"{self.room_id}_game",
   42             game_name=game_type,
   43             no_of_cards=3,  # This could be a parameter
   44             players=players_data
   45         )
   46
   47         # --- This is the flexible part ---
   48         # Based on the game_type string, we create the correct game object.
   49         if game_type == "TeenPatti":
   50             self.current_game = TeenPatti(game_instance, num_players=len(self.players))
   51         # elif game_type == "Poker":
   52         #     # When you create a Poker class, you would add it here
   53         #     self.current_game = Poker(game_instance, ...)
   54         else:
   55             print(f"Error: Unknown game type '{game_type}'")
   56             return
   57
   58         # Now that the game object is created, we can run it
   59         deck = CardDeck()
   60         shuffled_deck = deck.shuffle_deck()
   61         self.current_game.distribute_cards(shuffled_deck, game_instance.players)
   62
   63         # The Room starts and manages the game loop
   64         self.current_game.play_game_loop()
   65
   66         # After the loop finishes, the game is over
   67         print(f"\nGame of {game_type} has ended in room {self.room_id}.")
   68         self.current_game = None # Reset for the next game

